{% extends "bookmanage/base.html" %}
{% block head %}
  <!-- <script src="{{ STATIC_URL }}js/jquery.js"></script> -->
  <script src="{{ STATIC_URL }}js/jquery.ui.widget.js"></script>
  <!-- The Iframe Transport is required for browsers without support for XHR file uploads -->
  <script src="{{ STATIC_URL }}js/jquery.iframe-transport.js"></script>
  <!-- The basic File Upload plugin -->
  <script src="{{ STATIC_URL }}js/jquery.fileupload.js"></script>
  <!-- Calculate md5 -->
  <script src="{{ STATIC_URL }}js/spark-md5.js"></script>
{% endblock %}
{% block manage %}
<div class="ui grid container">
    <!-- basic example -->
    <div class="row">
    	<p id="progress"></p>
  		<div id="messages"></div>
    </div>
    <div class="row">
        <div class="column">
            <h2 class="ui header">Upload ROM & APK</h2>
            <hr />
            <form id="romapkform" class="ui form" role="form" method="post">
            	{% csrf_token %}
                {{ view.form|semanticui_inline }}
                <input name="upload_submit" type="submit" class="ui button" value="Submit" />
            </form>
        </div>
    </div>
</div>
{% endblock %}

{% block postscript %}
  <script type="text/javascript">
    var md5 = "",
        csrf = $("input[name='csrfmiddlewaretoken']")[0].value,
        form_data = [{"name": "csrfmiddlewaretoken", "value": csrf}];
    function calculate_md5(file, chunk_size) {
      var slice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice,
          chunks = chunks = Math.ceil(file.size / chunk_size),
          current_chunk = 0,
          spark = new SparkMD5.ArrayBuffer();
      function onload(e) {
        spark.append(e.target.result);  // append chunk
        current_chunk++;
        if (current_chunk < chunks) {
          read_next_chunk();
        } else {
          md5 = spark.end();
        }
      };
      function read_next_chunk() {
        var reader = new FileReader();
        reader.onload = onload;
        var start = current_chunk * chunk_size,
            end = Math.min(start + chunk_size, file.size);
        reader.readAsArrayBuffer(slice.call(file, start, end));
      };
      read_next_chunk();
    }
  function chuncked_upload_form(formnode, verbose) {
    var prestr="chuncked_upload_";
    function getName (subnode) {
      return subnode.name.substring(prestr.length);
    }
    function messageNode (subnode) {
      return $(formnode).find("[name=messages_"+getName(subnode)+"]");
    }
    function appendMessage (subnode, message) {
      if (!verbose) return;
      messageNode(subnode).append($('<p>').text(message));
    }
    function cleanMessage (subnode) {
      messageNode(subnode).empty();
    }
    function progressNode (subnode) {
      return $(formnode).find("[name=progress_"+getName(subnode)+"]");
    }
    function fileNode (subnode) {
      return $(formnode).find("#id_"+getName(subnode));
    }
    function md5Node (subnode) {
      return $(formnode).find("[name=md5_"+getName(subnode)+"]");
    }
    function uploadidNode (subnode) {
      return $(formnode).find("[name=uploadid_"+getName(subnode)+"]");
    }
    $(formnode).find("input[name^="+prestr+"]").fileupload({
      url: "{% url 'romapk_chunked_upload' %}",
      dataType: "json",
      maxChunkSize: 2000000, // Chunks of 2000 kB
      formData: form_data,
      add: function(e, data) { // Called before starting upload
        $(formnode).find("input[type=submit]").attr('disabled', true);
        messageNode(this).empty();
        fileNode(this).val(data.files[0].name);
        // If this is the second file you're uploading we need to remove the
        // old upload_id and just keep the csrftoken (which is always first).
        form_data.splice(1);
        calculate_md5(data.files[0], 2000000);  // Again, chunks of 2000 kB
        data.submit();
      },
      chunkdone: function (e, data) { // Called after uploading each chunk
        if (form_data.length < 2) {
          form_data.push(
            {"name": "upload_id", "value": data.result.upload_id}
          );
        }
        //appendMessage(this, JSON.stringify(data.result));
        var progress = parseInt(data.loaded / data.total * 100.0, 10);
        progressNode(this).text(Array(progress).join("=") + "> " + progress + "%");
      },
      done: function (e, data) { // Called when the file has completely uploaded
        var _this = this;
        var _data = data;
        md5Node(_this).val(md5);
        $.ajax({
          type: "POST",
          url: "{% url 'romapk_chunked_upload_complete' %}",
          data: {
            csrfmiddlewaretoken: csrf,
            upload_id: data.result.upload_id,
            md5: md5
          },
          dataType: "json",
          success: function(data) {
            appendMessage(_this, JSON.stringify(data));
            uploadidNode(_this).val(''+_data.result.upload_id);
            $(formnode).find("input[type=submit]").attr('disabled', false);
          }
        });
      },
    });
  }
  chuncked_upload_form("#romapkform", true);
  </script>
{% endblock %}
